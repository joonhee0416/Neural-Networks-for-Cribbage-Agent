import random
import numpy as np
import csv
import copy
from deck import Deck
from cribbage import Game
from pegging import Pegging
from my_policy import MyPolicy, MyPegger
from policy import CompositePolicy, GreedyThrower, GreedyPegger, ThrowPolicy, CribbagePolicy
import scoring
from tensorflow import keras
from keras.layers import Dense, Dropout
from keras.models import Sequential, load_model
from keras.optimizers import SGD

all_ranks = range(1, 14)
all_suits = ['S', 'H', 'D', 'C']
filename = "my_data.csv"

# used to de-normalize after calling model.predict()
ymin = -18
ymax = 19

def generate_random_hands():
    deck = Deck(all_ranks, all_suits, 1)
    deck.shuffle()
    return deck.deal(4), deck.deal(4)

def simulate_pegging_round(my_policy, opponent_policy, game):
    dealer = 0 if random.random() < 0.5 else 1
    history = Pegging()
    policies = [my_policy, opponent_policy]
    scores = [0, 0]
    passes = [False, False]

    my_hand, opponent_hand = generate_random_hands()
    peg_cards = [my_hand, opponent_hand]

    # copy hands for output to data
    initial_hand = []
    for card in my_hand:
        initial_hand.append(card.rank())

    peg_turn = 1 - dealer

    while (sum(len(cards) for cards in peg_cards) > 0 or not history.is_start_round()):
        if not passes[peg_turn]:
            play = policies[peg_turn].peg(copy.deepcopy(peg_cards[peg_turn]), history, None, [], dealer == peg_turn)

            if play is None and history.has_legal_play(game, peg_cards[peg_turn], 0 if peg_turn == dealer else 1):
                raise Exception("passing when has legal play")
            elif play is not None and not history.is_legal(game, play, 0 if peg_turn == dealer else 1):
                raise Exception("invalid card")
            
            if play is None:
                passes[peg_turn] = True
        else:
            play = None
        history, score = history.play(game, play, 0 if peg_turn == dealer else 1)
        if score > 0:
            scores[peg_turn] += score
        elif score < 0:
            scores[1 - peg_turn] += -score
        # remove played card from player's possible cards
        if play is not None:
            new_cards = [card for card in peg_cards[peg_turn] if card != play]
            if len(new_cards) == len(peg_cards[peg_turn]):
                raise Exception("played card not in hand")
            
            peg_cards[peg_turn] = new_cards
            
        # next player's turn
        peg_turn = 1 - peg_turn
        
        if sum(1 if passed else 0 for passed in passes) == 2:
            # both players passed; reset for next round of pegging
            passes = [False, False]  
    return initial_hand, scores

def generate_data():
    samples = 1000000
    with open(filename, mode='w', newline='') as file:
        writer = csv.writer(file) 
        for _ in range(samples):
            game = Game()
            hand, scores = simulate_pegging_round(MyPolicy(game), CompositePolicy(game, GreedyThrower(game), GreedyPegger(game)), game)
            score = scores[0] - scores[1]
            x_input = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            for i in range(len(hand)):
                x_input[hand[i]-1] += 0.25
            writer.writerow(x_input + [score])

def train():
    x_all = []
    y_all = []

    # fetch
    with open(filename, 'r') as file:
        reader = csv.reader(file)
        for row in reader:
            x_all.append([float(x) for x in row[:13]])
            y_all.append(int(row[13]))
    
    # normalize y data
    y_all = np.array(y_all)
    y_min = y_all.min()
    y_max = y_all.max()
    y_norm = (y_all - y_min) / (y_max - y_min)
    ymin = y_min
    ymin = y_max

    # get train data
    x_train = np.matrix(x_all)
    y_train = np.matrix(y_norm).T

    # 3 layer model
    model = Sequential()
    model.add(Dense(30, activation='relu', input_dim=x_train.shape[1]))
    model.add(Dropout(0.1))
    model.add(Dense(30, activation='relu', input_dim=x_train.shape[1]))
    model.add(Dropout(0.1))
    model.add(Dense(20, activation='relu', input_dim=x_train.shape[1]))
    model.add(Dropout(0.1))
    model.add(Dense(y_train.shape[1], activation="linear"))

    # compile and train
    model.compile(optimizer='adam', loss='mse')
    model.fit(x_train, y_train, epochs=100, batch_size=70)

    model.save('model6.h5')

    return

myCrib = {(1, 1): 5.532632230126818, (1, 2): 4.605512773903559, (1, 3): 4.764752606321363, (1, 4): 5.396252677551905, (1, 5): 5.516297153513775, (1, 6): 4.045447785855916, (1, 7): 4.062843181912294, (1, 8): 4.068488263066621, (1, 9): 3.706540161510086, (1, 10): 3.711570179092045, (1, 11): 3.9701519868156017, (1, 12): 3.6624875207986687, (1, 13): 3.5540848927430395, (2, 1): 4.605512773903559, (2, 2): 6.032548735192633, (2, 3): 7.111407156552703, (2, 4): 4.9429394525574715, (2, 5): 5.602704008530206, (2, 6): 4.2610020814748735, (2, 7): 4.253774483415462, (2, 8): 4.103817273659488, (2, 9): 4.072506675954952, (2, 10): 3.9309644162787407, (2, 11): 4.198587277184527, (2, 12): 3.859380834239153, (2, 13): 3.780305295329214, (3, 1): 4.764752606321363, (3, 2): 7.111407156552703, (3, 3): 6.236135402599127, (3, 4): 5.3476728251358, (3, 5): 6.273846638585785, (3, 6): 4.098613135646162, (3, 7): 4.166628102998049, (3, 8): 4.320262465454184, (3, 9): 4.044516497241499, (3, 10): 3.97912387927977, (3, 11): 4.225204996423997, (3, 12): 3.916421984202473, (3, 13): 3.843687673273472, (4, 1): 5.396252677551905, (4, 2): 4.9429394525574715, (4, 3): 5.3476728251358, (4, 4): 6.021167315175097, (4, 5): 6.687830555832751, (4, 6): 4.284514025222108, (4, 7): 4.123344999504738, (4, 8): 4.268557027910693, (4, 9): 4.01619644723093, (4, 10): 3.845808432934927, (4, 11): 4.118509074049543, (4, 12): 3.8021927255628243, (4, 13): 3.719837534226178, (5, 1): 5.516297153513775, (5, 2): 5.602704008530206, (5, 3): 6.273846638585785, (5, 4): 6.687830555832751, (5, 5): 8.763625566357279, (5, 6): 6.767382180316062, (5, 7): 6.184235066859836, (5, 8): 5.58267996853914, (5, 9): 5.445220471519992, (5, 10): 6.668522916270179, (5, 11): 6.9393225355722565, (5, 12): 6.612360617040418, (5, 13): 6.522841004806025, (6, 1): 4.045447785855916, (6, 2): 4.2610020814748735, (6, 3): 4.098613135646162, (6, 4): 4.284514025222108, (6, 5): 6.767382180316062, (6, 6): 6.069189165420807, (6, 7): 5.230263539191416, (6, 8): 4.909764762521374, (6, 9): 5.305798397244851, (6, 10): 3.382321609880324, (6, 11): 3.6019853287014496, (6, 12): 3.2929685890197566, (6, 13): 3.204902478466057, (7, 1): 4.062843181912294, (7, 2): 4.253774483415462, (7, 3): 4.166628102998049, (7, 4): 4.123344999504738, (7, 5): 6.184235066859836, (7, 6): 5.230263539191416, (7, 7): 6.221394077046903, (7, 8): 6.7983208629867375, (7, 9): 4.242475969506132, (7, 10): 3.3994650723725615, (7, 11): 3.6894465958362295, (7, 12): 3.388024407586857, (7, 13): 3.3151028059087477, (8, 1): 4.068488263066621, (8, 2): 4.103817273659488, (8, 3): 4.320262465454184, (8, 4): 4.268557027910693, (8, 5): 5.58267996853914, (8, 6): 4.909764762521374, (8, 7): 6.7983208629867375, (8, 8): 5.685408240366239, (8, 9): 4.825054282067857, (8, 10): 4.00806564909468, (8, 11): 3.681279014058912, (8, 12): 3.4118410180135514, (8, 13): 3.3212436949733717, (9, 1): 3.706540161510086, (9, 2): 4.072506675954952, (9, 3): 4.044516497241499, (9, 4): 4.01619644723093, (9, 5): 5.445220471519992, (9, 6): 5.305798397244851, (9, 7): 4.242475969506132, (9, 8): 4.825054282067857, (9, 9): 5.3134420449537245, (9, 10): 4.463545810129939, (9, 11): 4.062625859170869, (9, 12): 3.1639720377027185, (9, 13): 3.1199429200881235, (10, 1): 3.711570179092045, (10, 2): 3.9309644162787407, (10, 3): 3.97912387927977, (10, 4): 3.845808432934927, (10, 5): 6.668522916270179, (10, 6): 3.382321609880324, (10, 7): 3.3994650723725615, (10, 8): 4.00806564909468, (10, 9): 4.463545810129939, (10, 10): 4.973759005882742, (10, 11): 4.578275130872705, (10, 12): 3.653155323674066, (10, 13): 2.9544447017567075, (11, 1): 3.9701519868156017, (11, 2): 4.198587277184527, (11, 3): 4.225204996423997, (11, 4): 4.118509074049543, (11, 5): 6.9393225355722565, (11, 6): 3.6019853287014496, (11, 7): 3.6894465958362295, (11, 8): 3.681279014058912, (11, 9): 4.062625859170869, (11, 10): 4.578275130872705, (11, 11): 5.504442141928088, (11, 12): 4.614821690521378, (11, 13): 3.8928429817605075, (12, 1): 3.6624875207986687, (12, 2): 3.859380834239153, (12, 3): 3.916421984202473, (12, 4): 3.8021927255628243, (12, 5): 6.612360617040418, (12, 6): 3.2929685890197566, (12, 7): 3.388024407586857, (12, 8): 3.4118410180135514, (12, 9): 3.1639720377027185, (12, 10): 3.653155323674066, (12, 11): 4.614821690521378, (12, 12): 4.8016092863738296, (12, 13): 3.53905010107085, (13, 1): 3.5540848927430395, (13, 2): 3.780305295329214, (13, 3): 3.843687673273472, (13, 4): 3.719837534226178, (13, 5): 6.522841004806025, (13, 6): 3.204902478466057, (13, 7): 3.3151028059087477, (13, 8): 3.3212436949733717, (13, 9): 3.1199429200881235, (13, 10): 2.9544447017567075, (13, 11): 3.8928429817605075, (13, 12): 3.53905010107085, (13, 13): 4.632682797598022}
oppoCrib = {(1, 1): 5.791723741770138, (1, 2): 4.768574214231418, (1, 3): 4.915844779083237, (1, 4): 5.651464006201085, (1, 5): 5.928683822733593, (1, 6): 4.649991738268341, (1, 7): 4.508294339310116, (1, 8): 4.559680377042243, (1, 9): 4.3059303446213155, (1, 10): 4.1269304456476466, (1, 11): 4.3671904912520185, (1, 12): 4.065374376039934, (1, 13): 3.9734948757312973, (2, 1): 4.768574214231418, (2, 2): 6.153491132063031, (2, 3): 7.1963943325282, (2, 4): 5.122033025877743, (2, 5): 5.956132751324514, (2, 6): 4.767799914097862, (2, 7): 4.6923350863389786, (2, 8): 4.508658330852437, (2, 9): 4.521512331857159, (2, 10): 4.244347659535488, (2, 11): 4.512028919267046, (2, 12): 4.176448135947625, (2, 13): 4.092610125573052, (3, 1): 4.915844779083237, (3, 2): 7.1963943325282, (3, 3): 6.504992362018198, (3, 4): 5.664091006653789, (3, 5): 6.573927896255514, (3, 6): 4.611744617050518, (3, 7): 4.625590850494166, (3, 8): 4.677528257236004, (3, 9): 4.503808964507564, (3, 10): 4.344460115969284, (3, 11): 4.593200605425544, (3, 12): 4.289516562590464, (3, 13): 4.2183142301485494, (4, 1): 5.651464006201085, (4, 2): 5.122033025877743, (4, 3): 5.664091006653789, (4, 4): 6.25627570872707, (4, 5): 7.120846222931843, (4, 6): 4.944922303929724, (4, 7): 4.487329547330538, (4, 8): 4.598453340800343, (4, 9): 4.525144714799887, (4, 10): 4.2089973439575035, (4, 11): 4.457552324811234, (4, 12): 4.149151535650351, (4, 13): 4.0779405560564825, (5, 1): 5.928683822733593, (5, 2): 5.956132751324514, (5, 3): 6.573927896255514, (5, 4): 7.120846222931843, (5, 5): 9.176329564949633, (5, 6): 7.304530666644592, (5, 7): 6.738955221395147, (5, 8): 6.067019911412841, (5, 9): 6.039273839161891, (5, 10): 7.163165167600308, (5, 11): 7.41786343229903, (5, 12): 7.092985250786157, (5, 13): 7.005012469239789, (6, 1): 4.649991738268341, (6, 2): 4.767799914097862, (6, 3): 4.611744617050518, (6, 4): 4.944922303929724, (6, 5): 7.304530666644592, (6, 6): 6.770754551050919, (6, 7): 6.058495268217157, (6, 8): 5.584557663894285, (6, 9): 6.00543910192728, (6, 10): 4.049892641355549, (6, 11): 4.255419221216447, (6, 12): 3.948057728288015, (6, 13): 3.8823801194680043, (7, 1): 4.508294339310116, (7, 2): 4.6923350863389786, (7, 3): 4.625590850494166, (7, 4): 4.487329547330538, (7, 5): 6.738955221395147, (7, 6): 6.058495268217157, (7, 7): 6.72297073805376, (7, 8): 7.399720974264858, (7, 9): 4.988183626118661, (7, 10): 3.980722731939982, (7, 11): 4.260144639724622, (7, 12): 3.9543267243232516, (7, 13): 3.8897791269584547, (8, 1): 4.559680377042243, (8, 2): 4.508658330852437, (8, 3): 4.677528257236004, (8, 4): 4.598453340800343, (8, 5): 6.067019911412841, (8, 6): 5.584557663894285, (8, 7): 7.399720974264858, (8, 8): 6.179230188008356, (8, 9): 5.558864966104785, (8, 10): 4.641582718355137, (8, 11): 4.212519205035436, (8, 12): 3.9319699223268882, (8, 13): 3.8605646984768547, (9, 1): 4.3059303446213155, (9, 2): 4.521512331857159, (9, 3): 4.503808964507564, (9, 4): 4.525144714799887, (9, 5): 6.039273839161891, (9, 6): 6.00543910192728, (9, 7): 4.988183626118661, (9, 8): 5.558864966104785, (9, 9): 6.096077567210225, (9, 10): 5.144946632193053, (9, 11): 4.756977382794948, (9, 12): 3.8344542548080907, (9, 13): 3.8100674277321582, (10, 1): 4.1269304456476466, (10, 2): 4.244347659535488, (10, 3): 4.344460115969284, (10, 4): 4.2089973439575035, (10, 5): 7.163165167600308, (10, 6): 4.049892641355549, (10, 7): 3.980722731939982, (10, 8): 4.641582718355137, (10, 9): 5.144946632193053, (10, 10): 5.540661422874392, (10, 11): 5.217016764959247, (10, 12): 4.223772098896717, (10, 13): 3.519527243854832, (11, 1): 4.3671904912520185, (11, 2): 4.512028919267046, (11, 3): 4.593200605425544, (11, 4): 4.457552324811234, (11, 5): 7.41786343229903, (11, 6): 4.255419221216447, (11, 7): 4.260144639724622, (11, 8): 4.212519205035436, (11, 9): 4.756977382794948, (11, 10): 5.217016764959247, (11, 11): 6.027071713586561, (11, 12): 5.170875427851584, (11, 13): 4.458680280200899, (12, 1): 4.065374376039934, (12, 2): 4.176448135947625, (12, 3): 4.289516562590464, (12, 4): 4.149151535650351, (12, 5): 7.092985250786157, (12, 6): 3.948057728288015, (12, 7): 3.9543267243232516, (12, 8): 3.9319699223268882, (12, 9): 3.8344542548080907, (12, 10): 4.223772098896717, (12, 11): 5.170875427851584, (12, 12): 5.350305588532735, (12, 13): 4.100143670960089, (13, 1): 3.9734948757312973, (13, 2): 4.092610125573052, (13, 3): 4.2183142301485494, (13, 4): 4.0779405560564825, (13, 5): 7.005012469239789, (13, 6): 3.8823801194680043, (13, 7): 3.8897791269584547, (13, 8): 3.8605646984768547, (13, 9): 3.8100674277321582, (13, 10): 3.519527243854832, (13, 11): 4.458680280200899, (13, 12): 4.100143670960089, (13, 13): 5.180413281525962}

class NNPolicy(CribbagePolicy):
    def __init__(self, game):
        self._policy = CompositePolicy(game, NNThrower(game), MyPegger(game))
        
    def keep(self, hand, scores, am_dealer):
        return self._policy.keep(hand, scores, am_dealer)


    def peg(self, cards, history, turn, scores, am_dealer):
        return self._policy.peg(cards, history, turn, scores, am_dealer)

class NNThrower(ThrowPolicy):
    
    def __init__(self, game):
        super().__init__(game)
        self.model = load_model('model6.h5')

    def nn_throw(self, game, deal, crib, scores):
        throw_indices = game.throw_indices()
        all_inputs = []
        score_splits = []
        nn_multiplier = 1
        if 121 - scores[0] < 10:
            nn_multiplier = 4

        # collect all inputs for model.predict()
        for indices in throw_indices:
            keep, throw, crib_score = self.prepare_hand(deal, indices, crib)
            cards_for_input = np.zeros(13)
            for card in keep:
                cards_for_input[card.rank() - 1] += 0.25
            all_inputs.append(cards_for_input)
            score_splits.append((keep, throw, crib_score))

        # do batch prediction
        model_inputs = np.array(all_inputs)
        predicted_scores = self.model.predict(model_inputs, verbose=0) * (ymax - ymin) + ymin
        
        # calculate net scores
        for i, score_split in enumerate(score_splits):
            keep, throw, crib_score = score_split
            net_score = scoring.score(game, keep, None, False)[0] + crib_score + (predicted_scores[i][0] * nn_multiplier)
            score_splits[i] = (keep, throw, net_score)

        return max(score_splits, key=lambda t: t[2])

    def prepare_hand(self, deal, indices, crib):
        keep, throw = [], []
        crib_score = 0
        for i in range(len(deal)):
            if i in indices:
                throw.append(deal[i])
            else:
                keep.append(deal[i])
        
        if crib == 1:
            crib_score += myCrib[(throw[0].rank(), throw[1].rank())]
        else:
            crib_score -= oppoCrib[(throw[0].rank(), throw[1].rank())]
        
        return keep, throw, crib_score

    def keep(self, hand, scores, am_dealer):
        deck = self._game.deck()
        deck.remove(hand)
        keep, throw, net_score = self.nn_throw(self._game, hand, 1 if am_dealer else -1, scores)
        return keep, throw

if __name__ == "__main__":
    generate_data()
    train()
